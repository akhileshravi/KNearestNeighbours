{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Q1a"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "1. a)\n",
    "Akhilesh Ravi"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "from math import sqrt"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn.model_selection import train_test_split"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 71,
   "metadata": {},
   "outputs": [],
   "source": [
    "def distance(point1, point2, distance_metric='Euclidean'):\n",
    "\n",
    "    if distance_metric == 'Euclidean':\n",
    "        d = 0\n",
    "        for i in range(len(point1)):\n",
    "            d += (point1[i] - point2[i]) ** 2\n",
    "        return sqrt(d)\n",
    "    elif distance_metric == 'Manhattan':\n",
    "        d = 0\n",
    "        for i in range(len(point1)):\n",
    "            d += abs(point1[i] - point2[i])\n",
    "        return d\n",
    "    elif distance_metric == 'Cosine':\n",
    "        c1 = c2 = c3 = 0\n",
    "        for i in range(len(point1)):\n",
    "            c1 += point1[i] * point2[i]\n",
    "            c2 += point1[i] ** 2\n",
    "            c3 += point2[i] ** 2\n",
    "        cos = abs(c1) / (sqrt(c2) * sqrt(c3))\n",
    "        return 1 - cos\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 115,
   "metadata": {},
   "outputs": [],
   "source": [
    "def neighbours(test_point, train_X, train_Y, K, distance_metric = 'Euclidean'):\n",
    "    \n",
    "    distances = []\n",
    "    for i in range(len(train_X)):\n",
    "        point = tuple(train_X.iloc[i])\n",
    "        d = distance(test_point, point, distance_metric)\n",
    "        if type(train_Y.iloc[i]) == pd.core.series.Series:\n",
    "            distances.append((d, point, tuple(train_Y.iloc[i])))\n",
    "        else:\n",
    "            distances.append((d, point, train_Y.iloc[i]))\n",
    "    distances.sort(key=lambda x: (x[0],x[1],x[2]))\n",
    "    return distances[:K]\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 183,
   "metadata": {},
   "outputs": [],
   "source": [
    "def predict(typ, k_nearest):\n",
    "    if typ == 'classification':\n",
    "        counts = {}\n",
    "        for neighbour in k_nearest:\n",
    "            cls = neighbour[-1]\n",
    "            if cls not in counts:\n",
    "                counts[cls] = 1\n",
    "            else:\n",
    "                counts[cls] += 1\n",
    "        lst = [(cls, counts[cls]) for cls in counts]\n",
    "        lst.sort(key = lambda x: (x[1], x[0]), reverse=True)\n",
    "        max_count = lst[0][1]\n",
    "        if len(lst)>1:\n",
    "            for i in range(len(lst)):\n",
    "                if lst[i][1] != max_count:\n",
    "                    break\n",
    "            pred_index = np.random.choice(range(i))\n",
    "            pred = lst[pred_index]\n",
    "        else:\n",
    "            pred = lst[0]\n",
    "        return pred[0]\n",
    "    elif typ == 'regression':\n",
    "        c = 0\n",
    "        for neighbour in k_nearest:\n",
    "            c += neighbour[-1][0]\n",
    "        return c/len(k_nearest)\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 140,
   "metadata": {},
   "outputs": [],
   "source": [
    "def KNN_predict(typ, train_X, train_Y, test_X, K, distance_metric='Euclidean'):\n",
    "    pred = []\n",
    "    for i in range(len(test_X)):\n",
    "        point = tuple(test_X.iloc[i])\n",
    "        k_nearest = neighbours(point, train_X, train_Y, K, distance_metric)\n",
    "        out = predict(typ, k_nearest)\n",
    "        pred.append(out)\n",
    "    return pred"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 145,
   "metadata": {},
   "outputs": [],
   "source": [
    "def check_accuracy(typ, test_Y, predictions):\n",
    "    c = 0\n",
    "    if typ == 'classification':\n",
    "        if type(test_Y.iloc[0]) == pd.core.series.Series:\n",
    "            for i in range(len(predictions)):\n",
    "                if tuple(test_Y.iloc[i]) == predictions[i]:\n",
    "                    c += 1\n",
    "        else:\n",
    "            for i in range(len(predictions)):\n",
    "                if test_Y.iloc[i] == predictions[i]:\n",
    "                    c += 1\n",
    "        return c/len(predictions)\n",
    "    elif typ == 'regression':\n",
    "        e = 0\n",
    "        for i in range(len(predictions)):\n",
    "            e = (test_Y.iloc[i] - predictions[i]) ** 2\n",
    "        return math.sqrt(e/len(predictions))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "metadata": {},
   "outputs": [],
   "source": [
    "iris = pd.read_csv('iris.csv')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 123,
   "metadata": {},
   "outputs": [],
   "source": [
    "X = iris.copy()\n",
    "y = X['species']\n",
    "del X['species']\n",
    "\n",
    "train_X, test_X, train_Y, test_Y = train_test_split(X, y, test_size=0.33, random_state=42)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 142,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Accuracy: 0.98\n"
     ]
    }
   ],
   "source": [
    "#Model 1: K = 1, Euclidean Distance\n",
    "predictions_1 = KNN_predict('classification', train_X, train_Y, test_X, 1, distance_metric='Euclidean')\n",
    "print('Accuracy:',check_accuracy('classification', test_Y, predictions_1))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 143,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Accuracy: 0.98\n"
     ]
    }
   ],
   "source": [
    "#Model 2: K = 2, Euclidean Distance\n",
    "predictions_2 = KNN_predict('classification', train_X, train_Y, test_X, 2, distance_metric='Euclidean')\n",
    "print('Accuracy:',check_accuracy('classification', test_Y, predictions_1))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 146,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Accuracy: 0.98\n"
     ]
    }
   ],
   "source": [
    "#Model 3: K = 1, Cosine Distance\n",
    "predictions_3 = KNN_predict('classification', train_X, train_Y, test_X, 1, distance_metric='Cosine')\n",
    "print('Accuracy:',check_accuracy('classification', test_Y, predictions_1))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Q1b"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 154,
   "metadata": {},
   "outputs": [],
   "source": [
    "import time"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 188,
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 186,
   "metadata": {},
   "outputs": [],
   "source": [
    "def timecheck(train_size, dim):\n",
    "    data_X = np.random.random((train_size,dim))\n",
    "    data_Y = np.sum(data_X, axis=1)\n",
    "    dict_X = {}\n",
    "    \n",
    "    for i in range(len(data_X[0])):\n",
    "        dict_X['c'+str(i)] = data_X[:,i]\n",
    "    #dataset = pd.DataFrame({'Column1':data[:,0],'Column2':data[:,1]})\n",
    "    dataset_X = pd.DataFrame(dict_X)\n",
    "    \n",
    "    dataset_Y = pd.DataFrame({'Result':data_Y})\n",
    "    \n",
    "    train_X, test_X, train_Y, test_Y = train_test_split(dataset_X, dataset_Y, test_size=0.2, random_state=42)\n",
    "    \n",
    "    start = time.time()\n",
    "    predictions = KNN_predict('regression', train_X, train_Y, test_X, 2, distance_metric='Euclidean')\n",
    "    end = time.time()\n",
    "    \n",
    "    return end - start"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 189,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Varying number of train examples\n",
    "l = list(range(25, 501, 25))\n",
    "times = [0]*20\n",
    "for i in range(20):\n",
    "    times[i] = timecheck(l[i], 2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 193,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<matplotlib.collections.PathCollection at 0x7fa81493ed68>"
      ]
     },
     "execution_count": 193,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.scatter(l,times)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 203,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Varying number of dimensions\n",
    "l2 = list(range(1, 21))\n",
    "times2 = [0]*20\n",
    "for i in range(20):\n",
    "    times2[i] = timecheck(300, l2[i])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 204,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<matplotlib.collections.PathCollection at 0x7fa81464cb00>"
      ]
     },
     "execution_count": 204,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAXcAAAD8CAYAAACMwORRAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADl0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uIDMuMC4yLCBodHRwOi8vbWF0cGxvdGxpYi5vcmcvOIA7rQAAEwVJREFUeJzt3X+Q3HV9x/HXyyTWG0UOzWnJHXhaMVNLKmFuGNpYh0EkCExM09aJU6ZYGTPO1A4WG4YMnQzS6QBmapm29EdERwtaUItpJkojNck4dRr0wkGQQAAxVg4kJxIoY7QxvPvHfk+PZffuu/fd/e59P9/nY+Ym3/t+P7v75psvr/3u5/vebxwRAgCk5WX9LgAA0H2EOwAkiHAHgAQR7gCQIMIdABJEuANAggh3AEgQ4Q4ACSLcASBBi/v1wkuXLo3R0dF+vTwAVNK+fft+FBFDc43rW7iPjo5qfHy8Xy8PAJVk+/t5xjEtAwAJItwBIEGEOwAkiHAHgAQR7gCQoNzhbnuR7QnbO9psf6/tA7YfsP357pUIAOhUJ62Ql0t6UNKrmzfYPk3SJkmrIuIZ26/rUn0AgHnIdeZue0TSRZJubjPkg5JuiohnJCkiDnenPADAfOQ9c79R0pWSTmiz/S2SZPubkhZJuiYi/qN4eQCQjm0Tk9qy86CeOHJUywYHtHH1cq1dOdyT15oz3G1fLOlwROyzfc4sz3OapHMkjUj6hu0VEXGk6bk2SNogSaeeemqBsgGgWrZNTGrTHffr6LHjkqTJI0e16Y77JaknAZ9nWmaVpDW2D0m6TdK5tm9tGvO4pO0RcSwivifpYTXC/kUiYmtEjEXE2NDQnLdGAIBkbNl58BfBPu3osePasvNgT15vznCPiE0RMRIRo5LWS9oVEZc0Ddumxlm7bC9VY5rmse6WCgDV9cSRox2tL2refe62r7W9Jvt1p6SnbR+QtFvSxoh4uhsFAkAKlg0OdLS+qI7CPSL2RMTF2fLmiNieLUdEXBERb42IFRFxWy+KBYCq2rh6uQaWLHrRuoEli7Rx9fKevF7fbvkLAHUyfdF0wXTLAAC6Y+3K4Z6FeTPuLQMACSLcASBBhDsAJIhwB4AEEe4AkCDCHQASRLgDQIIIdwBIEOEOAAki3AEgQYQ7ACSIcAeABBHuAJAgwh0AEkS4A0CCCHcASBDhDgAJItwBIEGEOwAkiHAHgAQR7gCQIMIdABJEuANAggh3AEgQ4Q4ACSLcASBBucPd9iLbE7Z3zDLm92yH7bHulAcAmI9Oztwvl/Rgu422T8jG3F20KABAMbnC3faIpIsk3TzLsL+UdIOkn3ahLgBAAXnP3G+UdKWkF1pttH2mpFMi4ivdKgwAMH9zhrvtiyUdjoh9bba/TNInJH00x3NtsD1ue3xqaqrjYgEA+eQ5c18laY3tQ5Juk3Su7VtnbD9B0umS9mRjzpa0vdVF1YjYGhFjETE2NDRUuHgAQGtzhntEbIqIkYgYlbRe0q6IuGTG9mcjYmlEjGZj9kpaExHjvSoaADC7efe5277W9ppuFgMA6I7FnQyOiD2S9mTLm9uMOadoUQCAYviGKgAkiHAHgAQR7gCQIMIdABJEuANAggh3AEgQ4Q4ACSLcASBBhDsAJIhwB4AEEe4AkCDCHQASRLgDQIIIdwBIEOEOAAki3AEgQYQ7ACSIcAeABBHuAJAgwh0AEkS4A0CCCHcASBDhDgAJItwBIEGEOwAkiHAHgAQR7gCQIMIdABKUO9xtL7I9YXtHi21X2D5ge7/tr9t+Q3fLBAB0opMz98slPdhm24SksYj4TUlfkvTxooUBAOYvV7jbHpF0kaSbW22PiN0R8ZPs172SRrpTHgBgPvKeud8o6UpJL+QYe5mkO+ddEQCgsDnD3fbFkg5HxL4cYy+RNCZpS5vtG2yP2x6fmprquFgAQD55ztxXSVpj+5Ck2ySda/vW5kG2z5N0taQ1EfGzVk8UEVsjYiwixoaGhgqUDQCYzZzhHhGbImIkIkYlrZe0KyIumTnG9kpJ/6xGsB/uSaUAgNzm3edu+1rba7Jft0h6laQv2r7X9vauVAcAmJfFnQyOiD2S9mTLm2esP6+rVQEACuEbqgCQIMIdABJEuANAggh3AEgQ4Q4ACSLcASBBhDsAJIhwB4AEEe4AkCDCHQASRLgDQIIIdwBIEOEOAAki3AEgQYQ7ACSIcAeABBHuAJAgwh0AEkS4A0CCCHcASBDhDgAJItwBIEGEOwAkaHG/CwCAsmybmNSWnQf1xJGjWjY4oI2rl2vtyuF+l9UThDuAWtg2MalNd9yvo8eOS5ImjxzVpjvul6QkA55pGQC1sGXnwV8E+7Sjx45ry86Dfaqotwh3ALXwxJGjHa2vOsIdQC0sGxzoaH3V5Q5324tsT9je0WLbr9i+3fajtu+2PdrNIgGgqI2rl2tgyaIXrRtYskgbVy/vU0W91cmZ++WSHmyz7TJJz0TEmyX9jaQbihYGAN20duWwrlu3QsODA7Kk4cEBXbduRZIXU6Wc3TK2RyRdJOmvJF3RYsh7JF2TLX9J0t/bdkREN4oEgG5Yu3I42TBvlvfM/UZJV0p6oc32YUk/kKSI+LmkZyW9tnB1AIB5mTPcbV8s6XBE7Cv6YrY32B63PT41NVX06QAAbeQ5c18laY3tQ5Juk3Su7VubxkxKOkWSbC+WdKKkp5ufKCK2RsRYRIwNDQ0VKhwA0N6c4R4RmyJiJCJGJa2XtCsiLmkatl3Spdny72djmG8HgD6Z9+0HbF8raTwitkv6lKRbbD8q6cdqvAkAAPqko3CPiD2S9mTLm2es/6mkP+hmYQCA+ePGYQAqo053dSyKcAdQCXW7q2NR3FsGQCXU7a6ORRHuACqhbnd1LIpwB1AJdburY1GEO4BKqNtdHYvigiqASpi+aEq3TD6EO4DKqNNdHYsi3AEgpyr12RPuAJBD1frsuaAKADlUrc+ecAeAHKrWZ0+4A0AOVeuzJ9wBIIeq9dlzQRUAcqhanz3hDgA5VanPnnBHblXq8QXqjnBHLlXr8QXqjguqyKVqPb5A3RHuyKVqPb5A3RHuyKVqPb5A3RHuyKVqPb5A3XFBFblUrccXqDvCHblVqccXqDvCvUT0iQMoC+FeEvrEAZSJC6oloU8cQJk4c+9AkWkV+sQBlGnOM3fbr7D9Ldv32X7A9sdajDnV9m7bE7b3276wN+X2z/S0yuSRowr9clpl28RkrsfTJw6gTHmmZX4m6dyIeJukMyRdYPvspjF/IekLEbFS0npJ/9DdMvuv6LQKfeIAyjTntExEhKTns1+XZD/RPEzSq7PlEyU90a0CF4qi0yr0iQMoU645d9uLJO2T9GZJN0XE3U1DrpH0Ndt/KumVks7rZpELwbLBAU22CPJOplXoEwdQllzdMhFxPCLOkDQi6SzbpzcNeZ+kz0TEiKQLJd1i+yXPbXuD7XHb41NTU0Vr79i2iUmtun6X3njVV7Tq+l2558slplUAVEtHrZARcUTSbkkXNG26TNIXsjH/LekVkpa2ePzWiBiLiLGhoaH5VTxPRS+Irl05rOvWrdDw4IAsaXhwQNetW8GZOIAFac5pGdtDko5FxBHbA5LeJemGpmH/I+mdkj5j+9fVCPfyT81nMdsF0bwBXfVpFb4hC9RHnjn3kyV9Npt3f5kaXTE7bF8raTwitkv6qKRP2v4zNS6uvj+7ENtV9JnPH9+QBeolT7fMfkkrW6zfPGP5gKRV3S3txYqGUzcuiFZZNz65AKiOytx+gD7zYur+yQWom8qEezf6zOt8QZRvyAL1Upl7y9BnXszG1ctfNK0l1euTC1A3lTlzr/u0SlF1/+QC1E1lztz5+n5x/f7kQismUJ7KhLvU/3DC/NGKCZSrUuFed1U+86UVEygX4V4RVT/zpRUTKFdlLqjWXdX/mT5aMYFyEe4VUfUzX7qdgHIR7hVR9TNfWjGBcjHnXhEpfAmJbiegPIR7RdDnD6AThHuFcOYLIC/m3AEgQZy5AyhFlb+EV0WEO4Ceq/qX8KqIaRkAPVf1L+FVEeEOoOeq/iW8KiLcAfRc1b+EV0WEO4Ce4/YT5eOCKoCe40t45SPcAZSCL+GVi2kZAEgQ4Q4ACSLcASBBhDsAJIhwB4AEzRnutl9h+1u277P9gO2PtRn3XtsHsjGf736pAIC88rRC/kzSuRHxvO0lkv7L9p0RsXd6gO3TJG2StCoinrH9uh7VC2CeuCtjvcwZ7hERkp7Pfl2S/UTTsA9Kuikinskec7ibRQIS4VQEd2Wsn1xz7rYX2b5X0mFJd0XE3U1D3iLpLba/aXuv7QvaPM8G2+O2x6empopVjlqZDqfJI0cV+mU4bZuY7Hdppdk2MalV1+/SG6/6ilZdv6uj/3buylg/ucI9Io5HxBmSRiSdZfv0piGLJZ0m6RxJ75P0SduDLZ5na0SMRcTY0NBQscpRK3UPp6Jvbt24K2ORNxeUr6NumYg4Imm3pOYz88clbY+IYxHxPUkPqxH2QFfU/ZaxRd/cit6VkU9O1ZOnW2Zo+izc9oCkd0l6qGnYNjXO2mV7qRrTNI91tVLUWt1vGVv0za3oXRnr/smpivKcuZ8sabft/ZK+rcac+w7b19pek43ZKelp2wfUOLPfGBFP96Zk1FHdbxlb9M1t7cphXbduhYYHB2RJw4MDum7ditwXU+v+yamK8nTL7Je0ssX6zTOWQ9IV2Q/Qdd24ZWyVu202rl7+om4XqfM3tyJ3ZVw2OKDJFkFel09OVcQtf1EZRcJpIbQCFnlz6ff90Lvx5oJyEe6ohdnmjPMGZJFw7sabSz/vh97vNxd0jnBHLRSdMy4azt14c+k3/rGNauHGYaiFohcki3aLcEESZSPcUQtFu22KhnPdWzlRPsIdtVC0FbBoONe9lRPlY84dtVFkzrhotwgXJFE2wh3IoRvhzAVJlIlwB3IinFElzLkDQIIIdwBIEOEOAAki3AEgQYQ7ACSIcAeABBHuAJAgwh0AEuTGP6LUhxe2pyR9vy8vPrelkn7U7yJmQX3FUF8xC70+aeHXWKS+N0TE0FyD+hbuC5nt8YgY63cd7VBfMdRXzEKvT1r4NZZRH9MyAJAgwh0AEkS4t7a13wXMgfqKob5iFnp90sKvsef1MecOAAnizB0AElTbcLd9iu3dtg/YfsD25S3GnGP7Wdv3Zj+bS67xkO37s9ceb7Hdtv/W9qO299s+s8Tals/YL/fafs72R5rGlL7/bH/a9mHb35mx7jW277L9SPbnSW0ee2k25hHbl5ZU2xbbD2V/f1+2PdjmsbMeCz2s7xrbkzP+Di9s89gLbB/MjsWrSqzv9hm1HbJ9b5vHlrH/WmZK346/iKjlj6STJZ2ZLZ8g6WFJb20ac46kHX2s8ZCkpbNsv1DSnZIs6WxJd/epzkWSfqhG/21f95+kd0g6U9J3Zqz7uKSrsuWrJN3Q4nGvkfRY9udJ2fJJJdR2vqTF2fINrWrLcyz0sL5rJP15jr//70p6k6SXS7qv+f+lXtXXtP2vJW3u4/5rmSn9Ov5qe+YeEU9GxD3Z8v9KelBS1f6ZnfdI+pdo2Ctp0PbJfajjnZK+GxF9/1JaRHxD0o+bVr9H0mez5c9KWtvioasl3RURP46IZyTdJemCXtcWEV+LiJ9nv+6VNNLN1+xEm32Xx1mSHo2IxyLi/yTdpsY+76rZ6rNtSe+V9K/dft28ZsmUvhx/tQ33mWyPSlop6e4Wm3/L9n2277T9G6UWJoWkr9neZ3tDi+3Dkn4w4/fH1Z83qPVq/z9VP/fftNdHxJPZ8g8lvb7FmIWwLz+gxiexVuY6Fnrpw9m00afbTCkshH33O5KeiohH2mwvdf81ZUpfjr/ah7vtV0n6N0kfiYjnmjbfo8ZUw9sk/Z2kbSWX9/aIOFPSuyX9ie13lPz6c7L9cklrJH2xxeZ+77+XiMZn4AXXImb7akk/l/S5NkP6dSz8o6Rfk3SGpCfVmPpYiN6n2c/aS9t/s2VKmcdfrcPd9hI1/hI+FxF3NG+PiOci4vls+auSltheWlZ9ETGZ/XlY0pfV+Pg706SkU2b8PpKtK9O7Jd0TEU81b+j3/pvhqenpquzPwy3G9G1f2n6/pIsl/WH2P/9L5DgWeiIinoqI4xHxgqRPtnndvh6HthdLWifp9nZjytp/bTKlL8dfbcM9m6P7lKQHI+ITbcb8ajZOts9SY389XVJ9r7R9wvSyGhfevtM0bLukP8q6Zs6W9OyMj39laXvG1M/912S7pOnug0sl/XuLMTslnW/7pGzq4fxsXU/ZvkDSlZLWRMRP2ozJcyz0qr6Z13B+t83rflvSabbfmH2SW6/GPi/LeZIeiojHW20sa//Nkin9Of56efV4If9IersaH4/2S7o3+7lQ0ockfSgb82FJD6hx9X+vpN8usb43Za97X1bD1dn6mfVZ0k1qdCrcL2ms5H34SjXC+sQZ6/q6/9R4o3lS0jE15i0vk/RaSV+X9Iik/5T0mmzsmKSbZzz2A5IezX7+uKTaHlVjrnX6GPynbOwySV+d7Vgoqb5bsmNrvxohdXJzfdnvF6rRHfLdMuvL1n9m+pibMbYf+69dpvTl+OMbqgCQoNpOywBAygh3AEgQ4Q4ACSLcASBBhDsAJIhwB4AEEe4AkCDCHQAS9P8UZwPob8eOMAAAAABJRU5ErkJggg==\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.scatter(l2,times2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "train_X = pd.read_csv('iris.csv')\n",
    "for index, row in train_X[0:10].iterrows():\n",
    "    a = row\n",
    "\n",
    "print(type(a))\n",
    "for i in train_X.keys():\n",
    "    print(i)\n",
    "a1 = train_X[1:5]\n",
    "print(tuple(a1.iloc[0]))\n",
    "b = a1['species']\n",
    "print(a1.iloc[0])\n",
    "a2 = a1.copy()\n",
    "print(a1.iloc[0].eq(a2.iloc[0]))\n",
    "#a1.add(train_X.iloc[0])\n",
    "a1.iloc[2]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 133,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "3.8169999999999997"
      ]
     },
     "execution_count": 133,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#type(train_X.iloc[0]) == pd.core.series.Series\n",
    "np.mean(train_X['petal_length'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 153,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([ 1.43024355,  0.31693108,  1.21360093,  0.32869791,  1.3256457 ])"
      ]
     },
     "execution_count": 153,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.sum(np.random.random((5,2)), axis=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 192,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Help on function plot in module matplotlib.pyplot:\n",
      "\n",
      "plot(*args, scalex=True, scaley=True, data=None, **kwargs)\n",
      "    Plot y versus x as lines and/or markers.\n",
      "    \n",
      "    Call signatures::\n",
      "    \n",
      "        plot([x], y, [fmt], data=None, **kwargs)\n",
      "        plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)\n",
      "    \n",
      "    The coordinates of the points or line nodes are given by *x*, *y*.\n",
      "    \n",
      "    The optional parameter *fmt* is a convenient way for defining basic\n",
      "    formatting like color, marker and linestyle. It's a shortcut string\n",
      "    notation described in the *Notes* section below.\n",
      "    \n",
      "    >>> plot(x, y)        # plot x and y using default line style and color\n",
      "    >>> plot(x, y, 'bo')  # plot x and y using blue circle markers\n",
      "    >>> plot(y)           # plot y using x as index array 0..N-1\n",
      "    >>> plot(y, 'r+')     # ditto, but with red plusses\n",
      "    \n",
      "    You can use `.Line2D` properties as keyword arguments for more\n",
      "    control on the appearance. Line properties and *fmt* can be mixed.\n",
      "    The following two calls yield identical results:\n",
      "    \n",
      "    >>> plot(x, y, 'go--', linewidth=2, markersize=12)\n",
      "    >>> plot(x, y, color='green', marker='o', linestyle='dashed',\n",
      "    ...      linewidth=2, markersize=12)\n",
      "    \n",
      "    When conflicting with *fmt*, keyword arguments take precedence.\n",
      "    \n",
      "    **Plotting labelled data**\n",
      "    \n",
      "    There's a convenient way for plotting objects with labelled data (i.e.\n",
      "    data that can be accessed by index ``obj['y']``). Instead of giving\n",
      "    the data in *x* and *y*, you can provide the object in the *data*\n",
      "    parameter and just give the labels for *x* and *y*::\n",
      "    \n",
      "    >>> plot('xlabel', 'ylabel', data=obj)\n",
      "    \n",
      "    All indexable objects are supported. This could e.g. be a `dict`, a\n",
      "    `pandas.DataFame` or a structured numpy array.\n",
      "    \n",
      "    \n",
      "    **Plotting multiple sets of data**\n",
      "    \n",
      "    There are various ways to plot multiple sets of data.\n",
      "    \n",
      "    - The most straight forward way is just to call `plot` multiple times.\n",
      "      Example:\n",
      "    \n",
      "      >>> plot(x1, y1, 'bo')\n",
      "      >>> plot(x2, y2, 'go')\n",
      "    \n",
      "    - Alternatively, if your data is already a 2d array, you can pass it\n",
      "      directly to *x*, *y*. A separate data set will be drawn for every\n",
      "      column.\n",
      "    \n",
      "      Example: an array ``a`` where the first column represents the *x*\n",
      "      values and the other columns are the *y* columns::\n",
      "    \n",
      "      >>> plot(a[0], a[1:])\n",
      "    \n",
      "    - The third way is to specify multiple sets of *[x]*, *y*, *[fmt]*\n",
      "      groups::\n",
      "    \n",
      "      >>> plot(x1, y1, 'g^', x2, y2, 'g-')\n",
      "    \n",
      "      In this case, any additional keyword argument applies to all\n",
      "      datasets. Also this syntax cannot be combined with the *data*\n",
      "      parameter.\n",
      "    \n",
      "    By default, each line is assigned a different style specified by a\n",
      "    'style cycle'. The *fmt* and line property parameters are only\n",
      "    necessary if you want explicit deviations from these defaults.\n",
      "    Alternatively, you can also change the style cycle using the\n",
      "    'axes.prop_cycle' rcParam.\n",
      "    \n",
      "    Parameters\n",
      "    ----------\n",
      "    x, y : array-like or scalar\n",
      "        The horizontal / vertical coordinates of the data points.\n",
      "        *x* values are optional. If not given, they default to\n",
      "        ``[0, ..., N-1]``.\n",
      "    \n",
      "        Commonly, these parameters are arrays of length N. However,\n",
      "        scalars are supported as well (equivalent to an array with\n",
      "        constant value).\n",
      "    \n",
      "        The parameters can also be 2-dimensional. Then, the columns\n",
      "        represent separate data sets.\n",
      "    \n",
      "    fmt : str, optional\n",
      "        A format string, e.g. 'ro' for red circles. See the *Notes*\n",
      "        section for a full description of the format strings.\n",
      "    \n",
      "        Format strings are just an abbreviation for quickly setting\n",
      "        basic line properties. All of these and more can also be\n",
      "        controlled by keyword arguments.\n",
      "    \n",
      "    data : indexable object, optional\n",
      "        An object with labelled data. If given, provide the label names to\n",
      "        plot in *x* and *y*.\n",
      "    \n",
      "        .. note::\n",
      "            Technically there's a slight ambiguity in calls where the\n",
      "            second label is a valid *fmt*. `plot('n', 'o', data=obj)`\n",
      "            could be `plt(x, y)` or `plt(y, fmt)`. In such cases,\n",
      "            the former interpretation is chosen, but a warning is issued.\n",
      "            You may suppress the warning by adding an empty format string\n",
      "            `plot('n', 'o', '', data=obj)`.\n",
      "    \n",
      "    \n",
      "    Other Parameters\n",
      "    ----------------\n",
      "    scalex, scaley : bool, optional, default: True\n",
      "        These parameters determined if the view limits are adapted to\n",
      "        the data limits. The values are passed on to `autoscale_view`.\n",
      "    \n",
      "    **kwargs : `.Line2D` properties, optional\n",
      "        *kwargs* are used to specify properties like a line label (for\n",
      "        auto legends), linewidth, antialiasing, marker face color.\n",
      "        Example::\n",
      "    \n",
      "        >>> plot([1,2,3], [1,2,3], 'go-', label='line 1', linewidth=2)\n",
      "        >>> plot([1,2,3], [1,4,9], 'rs',  label='line 2')\n",
      "    \n",
      "        If you make multiple lines with one plot command, the kwargs\n",
      "        apply to all those lines.\n",
      "    \n",
      "        Here is a list of available `.Line2D` properties:\n",
      "    \n",
      "          agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array \n",
      "      alpha: float\n",
      "      animated: bool\n",
      "      antialiased: bool\n",
      "      clip_box: `.Bbox`\n",
      "      clip_on: bool\n",
      "      clip_path: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None] \n",
      "      color: color\n",
      "      contains: callable\n",
      "      dash_capstyle: {'butt', 'round', 'projecting'}\n",
      "      dash_joinstyle: {'miter', 'round', 'bevel'}\n",
      "      dashes: sequence of floats (on/off ink in points) or (None, None)\n",
      "      drawstyle: {'default', 'steps', 'steps-pre', 'steps-mid', 'steps-post'}\n",
      "      figure: `.Figure`\n",
      "      fillstyle: {'full', 'left', 'right', 'bottom', 'top', 'none'}\n",
      "      gid: str\n",
      "      in_layout: bool\n",
      "      label: object\n",
      "      linestyle: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}\n",
      "      linewidth: float\n",
      "      marker: unknown\n",
      "      markeredgecolor: color\n",
      "      markeredgewidth: float\n",
      "      markerfacecolor: color\n",
      "      markerfacecoloralt: color\n",
      "      markersize: float\n",
      "      markevery: unknown\n",
      "      path_effects: `.AbstractPathEffect`\n",
      "      picker: float or callable[[Artist, Event], Tuple[bool, dict]]\n",
      "      pickradius: float\n",
      "      rasterized: bool or None\n",
      "      sketch_params: (scale: float, length: float, randomness: float) \n",
      "      snap: bool or None\n",
      "      solid_capstyle: {'butt', 'round', 'projecting'}\n",
      "      solid_joinstyle: {'miter', 'round', 'bevel'}\n",
      "      transform: matplotlib.transforms.Transform\n",
      "      url: str\n",
      "      visible: bool\n",
      "      xdata: 1D array\n",
      "      ydata: 1D array\n",
      "      zorder: float\n",
      "    \n",
      "    Returns\n",
      "    -------\n",
      "    lines\n",
      "        A list of `.Line2D` objects representing the plotted data.\n",
      "    \n",
      "    \n",
      "    See Also\n",
      "    --------\n",
      "    scatter : XY scatter plot with markers of varying size and/or color (\n",
      "        sometimes also called bubble chart).\n",
      "    \n",
      "    \n",
      "    Notes\n",
      "    -----\n",
      "    **Format Strings**\n",
      "    \n",
      "    A format string consists of a part for color, marker and line::\n",
      "    \n",
      "        fmt = '[color][marker][line]'\n",
      "    \n",
      "    Each of them is optional. If not provided, the value from the style\n",
      "    cycle is used. Exception: If ``line`` is given, but no ``marker``,\n",
      "    the data will be a line without markers.\n",
      "    \n",
      "    **Colors**\n",
      "    \n",
      "    The following color abbreviations are supported:\n",
      "    \n",
      "    =============    ===============================\n",
      "    character        color\n",
      "    =============    ===============================\n",
      "    ``'b'``          blue\n",
      "    ``'g'``          green\n",
      "    ``'r'``          red\n",
      "    ``'c'``          cyan\n",
      "    ``'m'``          magenta\n",
      "    ``'y'``          yellow\n",
      "    ``'k'``          black\n",
      "    ``'w'``          white\n",
      "    =============    ===============================\n",
      "    \n",
      "    If the color is the only part of the format string, you can\n",
      "    additionally use any  `matplotlib.colors` spec, e.g. full names\n",
      "    (``'green'``) or hex strings (``'#008000'``).\n",
      "    \n",
      "    **Markers**\n",
      "    \n",
      "    =============    ===============================\n",
      "    character        description\n",
      "    =============    ===============================\n",
      "    ``'.'``          point marker\n",
      "    ``','``          pixel marker\n",
      "    ``'o'``          circle marker\n",
      "    ``'v'``          triangle_down marker\n",
      "    ``'^'``          triangle_up marker\n",
      "    ``'<'``          triangle_left marker\n",
      "    ``'>'``          triangle_right marker\n",
      "    ``'1'``          tri_down marker\n",
      "    ``'2'``          tri_up marker\n",
      "    ``'3'``          tri_left marker\n",
      "    ``'4'``          tri_right marker\n",
      "    ``'s'``          square marker\n",
      "    ``'p'``          pentagon marker\n",
      "    ``'*'``          star marker\n",
      "    ``'h'``          hexagon1 marker\n",
      "    ``'H'``          hexagon2 marker\n",
      "    ``'+'``          plus marker\n",
      "    ``'x'``          x marker\n",
      "    ``'D'``          diamond marker\n",
      "    ``'d'``          thin_diamond marker\n",
      "    ``'|'``          vline marker\n",
      "    ``'_'``          hline marker\n",
      "    =============    ===============================\n",
      "    \n",
      "    **Line Styles**\n",
      "    \n",
      "    =============    ===============================\n",
      "    character        description\n",
      "    =============    ===============================\n",
      "    ``'-'``          solid line style\n",
      "    ``'--'``         dashed line style\n",
      "    ``'-.'``         dash-dot line style\n",
      "    ``':'``          dotted line style\n",
      "    =============    ===============================\n",
      "    \n",
      "    Example format strings::\n",
      "    \n",
      "        'b'    # blue markers with default shape\n",
      "        'ro'   # red circles\n",
      "        'g-'   # green solid line\n",
      "        '--'   # dashed line with default color\n",
      "        'k^:'  # black triangle_up markers connected by a dotted line\n",
      "    \n",
      "    .. note::\n",
      "        In addition to the above described arguments, this function can take a\n",
      "        **data** keyword argument. If such a **data** argument is given, the\n",
      "        following arguments are replaced by **data[<arg>]**:\n",
      "    \n",
      "        * All arguments with the following names: 'x', 'y'.\n",
      "    \n",
      "        Objects passed as **data** must support item access (``data[<arg>]``) and\n",
      "        membership test (``<arg> in data``).\n",
      "\n"
     ]
    }
   ],
   "source": [
    "help(plt.plot)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
